<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Embree: High Performance Ray Tracing Kernels" />
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <title>Embree</title>
    <link rel="SHORTCUT ICON" HREF="images/icon32.ico">
  </head>
  
  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <div class="inner">
        <a id="forkme_banner" href="https://github.com/embree">View on GitHub</a>
        <h1 id="project_title">Embree</h1>
        <h2 id="project_tagline">High Performance Ray Tracing Kernels</h2>
      </div>

      <div id="nav">
      <div id="nbar">
        <ul>
          <li><a href="index.html">Overview</a></li>
          <li><a href="downloads.html">Downloads</a></li>
          <li><a href="api.html">API</a></li>
          <li id="selected"><a href="tutorials.html">Tutorials</a></li>
          <li><a href="renderer.html">Renderer</a></li>
        </ul>
      </div>
      </div>

    </div>
    
    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <div id="main_content" class="inner">

<h2>Embree Tutorials</h2>

<p>Embree comes with a set of tutorials aimed at helping users
understand how embree can be used and extended. All tutorials exist in
an ISPC and C version to demonstrate the two versions of the API. Look
for files names <pre><code>tutorialXX_device.ispc</code></pre> for the ISPC
implementation of the tutorial, and files named
<pre><code>tutorialXX_device.cpp</code></pre> for the single ray C version of the
tutorial. To start the C++ version
use the <pre><code>tutorialXX</code></pre> executables, to start the ISPC version
use the <pre><code>tutorialXX_ispc</code></pre> executables.

You can select an initial camera using the -vp (camera position), -vi
(camera lookat point), -vu (camera up vector), and -fov (vertical
field of view) command line parameters:

<p><pre><code>
  ./tutorial00 -vp 10 10 10 -vi 0 0 0
</code></pre></p>

You can select the initial windows size using the -size command line
parameter, or start the tutorials in fullscreen using the -fullscreen
parameter:

<p><pre><code>
  ./tutorial00 -size 1024 1024
  ./tutorial00 -fullscreen
</code></pre></p>

Implementation specific parameters can be passed to the ray tracing
core through the -rtcore command line parameter, e.g.:

<p><pre><code>
  ./tutorial00 -rtcore verbose=2,threads=1,accel=bvh4.triangle1
</code></pre></p>

<p>The navigation in the interactive display mode follows the camera
orbit model, where the camera revolves around the current center of
interest. With the left mouse button you can rotate around the center
of interest (the point initially set with -vi). Holding Control
pressed while klicking the left mouse button rotates the camera around
its location. You can also use the arrow keys for navigation.</p>

<p>You can use the following keys:</p>

<dl>
    <dt>F1</dt>     <dd>Default shading</dd>
    <dt>F2</dt>     <dd>Gray EyeLight shading</dd>
    <dt>F3</dt>     <dd>Ambient occlusion shading</dd>
    <dt>F4</dt>     <dd>UV Coordinate visualization</dd>
    <dt>F5</dt>     <dd>Geometry normal visualization</dd>
    <dt>F6</dt>     <dd>Geometry ID visualization</dd>
    <dt>F7</dt>     <dd>Geometry ID and Primitive ID visualization</dd>
    <dt>F8</dt>     <dd>Simple shading with 16 rays per pixel for benchmarking.</dd>
    <dt>F9</dt>     <dd>Switches to render cost visualization. Pressing again reduces brightness.</dd>
    <dt>F10</dt>    <dd>Switches to render cost visualization. Pressing again increases brightness.</dd>
    <dt>f</dt>      <dd>Enters or leaves full screen mode.</dd>
    <dt>c</dt>      <dd>Prints camera parameters.</dd>
    <dt>ESC</dt>    <dd>Exists the tutorial.</dd>
    <dt>q</dt>      <dd>Exists the tutorial.</dd>
</dl>

<h3>Tutorial00</h3>

<table>
<tr>
  <td><img src="images/tutorial00.jpg" style="width: 20mm"></td>
  <td><p>This tutorial demonstrates the creation of a static cube and
ground plane using triangle meshes. It also demonstrates the use of
the <code>rtcIntersect</code> and <code>rtcOccluded</code> functions to
render primary visibility and hard shadows. The cube sides are colored
based on the ID of the hit primitive.</p></td>
</tr>
</table>

      </div>
    </div>
    
  </body>
</html>
